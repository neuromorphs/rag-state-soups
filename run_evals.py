# -*- coding: utf-8 -*-
"""Get_evals.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1uaRn-XA3jXF0PmLArUhlFyToHxLAXlbD
"""
# !pip install transformers accelerate datasets
from datasets import load_dataset
from transformers import AutoTokenizer
from transformers import MambaConfig, MambaForCausalLM
from tqdm import tqdm
import argparse
import numpy as np
import os
import torch
import pandas as pd
import copy
import json
from dataclasses import dataclass
from typing import List, Union


def parse_args():
    parser = argparse.ArgumentParser()
    parser.add_argument("--model_folder", type=str, default="./model-folder")
    parser.add_argument("--dataset_path", type=str, default="./dataset/ragdataset-MC-QA.csv")
    parser.add_argument("--embedding_folder", type=str, default="./ssm-states")
    parser.add_argument("--results_folder", type=str, default="./results")
    parser.add_argument("--n_examples", type=int, default=None)
    return parser.parse_args()

def soup_fn(context, query, context_lambda=0.9, query_lambda=None):
  query_lambda = query_lambda if query_lambda is not None else (1. - context_lambda)
  return context * context_lambda + query * query_lambda

def format_context(ex):
  question = f"Answer the following multiple-choice question with a single number: {ex['question']}\n" + '\n'.join([f'{i+1}:' + ex[f'answer_{i}'] for i in range(4)])
  return question

@dataclass
class Configuration:
  """Configuration for a single run."""
  layers: List[int]
  ssm_ratio: float
  conv_ratio: float

  def __post_init__(self):
    if isinstance(self.layers, int):
      self.layers = [self.layers]

  def __str__(self):
    l = self.layers if isinstance(self.layers, int) or len(self.layers) == 1 else f"N{len(self.layers)}"
    return f"layers_{l}_ssm_{self.ssm_ratio}_conv_{self.conv_ratio}"


args = parse_args()
model_folder = args.model_folder
dataset_path = args.dataset_path
embedding_folder = args.embedding_folder
results_folder = args.results_folder
os.makedirs(results_folder, exist_ok=True)
write_path = os.path.join(results_folder, 'results.csv')
n_examples = args.n_examples

device = "cuda"

print("Loading Mamba model from local checkpoint")
model = MambaForCausalLM.from_pretrained(model_folder).cuda()

# setup tokenizer
tokenizer = AutoTokenizer.from_pretrained("Schmadge/mamba-slim-orca")
tokenizer.eos_token = tokenizer.pad_token = "<|endoftext|>"
tokenizer.chat_template = AutoTokenizer.from_pretrained("HuggingFaceH4/zephyr-7b-beta").chat_template

# load dataset with multiple choice questions
ds = pd.read_csv(dataset_path, nrows=n_examples)

n_ssm_layers = 64
list_layers_to_apply = [int(percent*n_ssm_layers) for percent in [0.25, 0.5, 0.75]]
list_ssm_ratio_to_apply = [0.5, 0.7, 0.9]
list_conv_ratio_to_apply = [0.0, 0.5]

conditions = []
for layers in list_layers_to_apply:
  for ssm_ratio in list_ssm_ratio_to_apply:
    for conv_ratio in list_conv_ratio_to_apply:
      conditions.append(Configuration(layers=layers, ssm_ratio=ssm_ratio, conv_ratio=conv_ratio))
conditions.append(Configuration(layers=[], ssm_ratio=0.0, conv_ratio=0.0))
print(f"Compiled {len(conditions)} conditions")

results = []
for qa_id in tqdm(range(n_examples)):
  # load question and correct answer from dataset
  row = ds.iloc[qa_id]
  question = format_context(row)
  corect_ans = np.where([row[f'correct_{i}'] for i in range(4)])[0][0]

  # load the context embedding as Mamba cache
  cache_path = os.path.join(embedding_folder, f"context_{qa_id}.npz")
  cache_context = np.load(cache_path, allow_pickle=True)

  # create the prompt for the question
  prompt = [{"role": "user", "content": question}]
  query_input_ids = tokenizer.apply_chat_template(prompt, return_tensors="pt", add_generation_prompt=True).to(device)

  for condition in tqdm(conditions):
    # forward pass with query to collect hidden state
    query_out = model(input_ids=query_input_ids, max_new_tokens=1, return_dict=True)
    cache_query = query_out.cache_params

    # apply the souping
    cache_soup = copy.copy(cache_query)
    cache_soup.ssm_states = {
        k: soup_fn(
          torch.from_numpy(cache_context['ssm_states'].item()[k]).cuda(),
          cache_query.ssm_states[k],
          condition.ssm_ratio if (k in condition.layers) else 0.0,  # 0.0 <> no context
        )
        for k in cache_soup.ssm_states.keys()
    }
    cache_soup.conv_states = {
        k: soup_fn(
          torch.from_numpy(cache_context['conv_states'].item()[k]).cuda(),
          cache_query.conv_states[k],
          condition.conv_ratio if (k in condition.layers) else 0.0,  # 0.0 <> no context
        )
        for k in cache_soup.conv_states.keys()
    }
    # TODO: right now we're always takign the max of the two seqlen_offsets, but we could be more clever
    cache_soup.seqlen_offset = max([cache_context['seqlen_offset'], cache_query.seqlen_offset])

    # generate the answer with souping
    out = model.generate(
            input_ids=query_input_ids, max_new_tokens=1,
            return_dict_in_generate=True,
            output_logits=True, cache_params=copy.copy(cache_soup)
    )

    # extract the answer ordering from the logits
    logit_idxs = {c: tokenizer.encode(c) for c in "1234"}
    choices = sorted([(out.logits[0][0, logit_idxs[char]].detach().item(), char) for char in logit_idxs.keys()])[::-1]

    outfull = model.generate(
            input_ids=query_input_ids, max_new_tokens=100,
            cache_params=copy.copy(cache_soup)
    )

    # store the results for this sample
    results.append({
      'sample_id': row['sample_id'],
      'condition': str(condition),
      'correct_answer': corect_ans,
      'model_answer': int(choices[0][1]),
      'correct': corect_ans == int(choices[0][1]),
      'answer_rankings': choices,
      'full_answer': tokenizer.decode(outfull[0]),
    })

    # save the results to a file
    pd.DataFrame(results).to_csv(write_path, index=True, header=True)
